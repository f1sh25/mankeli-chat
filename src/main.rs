use mankeli_chat::StatusLabel;
use mankeli_chat::api::FriendRequestStatus;
use mankeli_chat::db::{
    FriendRequest, Message, User, delete_message, delete_user, fetch_inbox, fetch_outgoing,
    fetch_users, retr_user, send_invite, send_message_to_que, setup_db,
};
use sqlx::{ConnectOptions, SqlitePool, sqlite::SqliteConnectOptions};
use std::io::{self, Write};
use std::str::FromStr;
use tracing::log::LevelFilter;

#[cfg(test)]
mod tests;

#[tokio::main]
async fn main() {
    // Configure logging for SQLx
    let options = SqliteConnectOptions::from_str("sqlite://mankeli.db")
        .expect("Failed to parse database URL")
        .log_statements(LevelFilter::Debug)
        .create_if_missing(true);

    let pool = SqlitePool::connect_with(options)
        .await
        .expect("Failed to connect to database");

    let username = read_input("Enter Username: ");

    let user: User = match retr_user(&pool).await {
        Ok(u) => {
            println!("\nWelcome back {}!\n", u.username);
            u
        }
        Err(e) => {
            eprintln!(
                "User not found or error retrieving user: {}. Initializing new user.",
                e
            );
            init_db(&pool, username).await
        }
    };

    println!("\nWelcome {}!\n", &user.username);

    loop {
        let prompt =
            "\nAvailable commands: inbox, friends, send, outbound, quit\nPlease enter something: ";

        let cmd = read_input(prompt).to_lowercase();

        match cmd.as_str() {
            "inbox" => read_inbox(&pool).await,
            "friends" => read_friends(&pool).await,
            "send" => send_message(&pool).await,
            "outbound" => view_outbound(&pool).await,
            "quit" => {
                println!("Goodbye!");
                break;
            }
            _ => println!("Unknown command."),
        }
    }
}

fn read_input(prompt: &str) -> String {
    print!("{}", prompt);
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .expect("Failed to read input");
    input.trim().to_string()
}

async fn init_db(pool: &SqlitePool, username: String) -> User {
    let user = User {
        id: 0, // ID will be auto-generated by the DB
        username: username,
        address: "127.0.0.1".to_string(),
    };

    setup_db(pool, &user)
        .await
        .expect("Failed to set up database");

    retr_user(pool)
        .await
        .expect("Failed to retrieve newly created user")
}

async fn read_inbox(pool: &SqlitePool) {
    let inbox = match fetch_inbox(pool).await {
        Ok(messages) => messages,
        Err(e) => {
            eprintln!("Error fetching inbox: {}", e);
            return;
        }
    };

    if inbox.is_empty() {
        println!("You don't have any mail.");
        return;
    }

    println!("Your inbox:");
    for (i, message) in inbox.iter().enumerate() {
        println!(
            "{}. From: {}, Subject: {}",
            i + 1,
            message.sender,
            message.subject
        );
    }

    loop {
        print!("\nEnter message number to read in full, or 'b' to go back: ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        if let Err(_) = io::stdin().read_line(&mut input) {
            println!("Failed to read input. Try again.");
            continue;
        }

        let input = input.trim();

        if input.eq_ignore_ascii_case("b") {
            println!("Returning to main menu...");
            break;
        }

        match input.parse::<usize>() {
            Ok(index) if index > 0 && index <= inbox.len() => {
                let message = &inbox[index - 1];
                println!(
                    "\nFrom: {}\nSubject: {}\n\n{}",
                    message.sender, message.subject, message.message
                );

                print!("Delete this message? (y/n): ");
                io::stdout().flush().unwrap();

                let mut del_input = String::new();
                if let Ok(_) = io::stdin().read_line(&mut del_input) {
                    if del_input.trim().eq_ignore_ascii_case("y") {
                        match delete_message(pool, message.id).await {
                            Ok(_) => println!("Message deleted."),
                            Err(e) => println!("Failed to delete message: {}", e),
                        }
                    }
                }

                break;
            }
            _ => {
                println!("Invalid input. Please enter a valid number or 'b'.");
            }
        }
    }
}

async fn read_friends(pool: &SqlitePool) {
    loop {
        let friends = match fetch_users(pool).await {
            Ok(friends) => friends,
            Err(e) => {
                eprintln!("Error fetching users: {}", e);
                return;
            }
        };

        println!("Your friends:");

        if friends.is_empty() {
            println!("You don't have any friends yet.");
        } else {
            println!(
                "{:<4} {:<15} {:<25} {:<18} {}",
                "ID", "Username", "Address", "Status", "Added At (UTC)"
            );
            println!("{}", "-".repeat(80));
            for fr in friends {
                println!(
                    "{:<4} {:<15} {:<25} {:<18} {}",
                    fr.id,
                    fr.username,
                    fr.address,
                    fr.status.status_str(),
                    fr.added_at
                        .map(|dt| dt.to_string())
                        .unwrap_or("N/A".to_string())
                );
            }
        }

        let response = read_input("a: Add Friend, r: remove Friend, b: go back: ").to_lowercase();

        if response.as_str() == "b" {
            println!("Returning to main menu...");
            break;
        }

        match response.as_str() {
            "a" => {
                let username = read_input("Enter username of user: ");
                let address = read_input("Enter ip/hostname of user: ");
                let request = FriendRequest {
                    username: username,
                    address: address,
                };
                match send_invite(pool, &request).await {
                    Ok(_) => println!("Friend invite sent!"),
                    Err(e) => {
                        eprintln!("Error sending invite: {}", e);
                    }
                };
            }
            "r" => {
                let id = read_input("Enter friend id to remove them: ");

                match id.trim().parse::<i64>() {
                    Ok(friend_id) => {
                        println!("Removing friend with id: {}", friend_id);
                        match delete_user(pool, friend_id).await {
                            Ok(_) => println!("Friend removed."),
                            Err(e) => eprintln!("Failed to remove friend: {}", e),
                        }
                    }
                    Err(e) => {
                        println!("Invalid input: must be a number. Error: {}", e);
                    }
                }
            }
            _ => {
                println!("Invalid input. Please enter 'a', 'r', or 'b'.");
            }
        }
    }
}

async fn send_message(pool: &SqlitePool) {
    println!("Please fill the following fields");
    let send_to = read_input("Recipient: ");
    let subject = read_input("Subject: ");
    let content = read_input("Content: ");

    let message = Message {
        send_to,
        subject,
        content,
    };

    match send_message_to_que(pool, &message).await {
        Ok(_) => println!("Message queued!"),
        Err(e) => {
            eprintln!("Error queuing message: {}", e);
        }
    };
}

async fn view_outbound(pool: &SqlitePool) {
    let outbound = match fetch_outgoing(pool).await {
        Ok(outbound) => outbound,
        Err(e) => {
            eprintln!("Error fetching outbound messages: {}", e);
            return;
        }
    };

    println!("Your outbound mail:");
    if outbound.is_empty() {
        println!("You don't have any outbound messages.");
    } else {
        for message in outbound {
            println!(
                "To: {} | Subject: {} | Sent: {:?}",
                message.recipient, message.subject, message.sent
            )
        }
    }
}
