use mankeli_chat::StatusLabel;
use mankeli_chat::api::app;
use mankeli_chat::comms::{friend_fetcher, message_fetcher};
use mankeli_chat::db::{
    FriendRequest, MIGRATOR, OutgoingMessage, User, delete_message, delete_user, fetch_inbox,
    fetch_outgoing, fetch_users, invite_decision, retr_user, send_invite, send_message_to_que,
    setup_db,
};
use serde::Deserialize;
use sqlx::{ConnectOptions, SqlitePool, sqlite::SqliteConnectOptions};
use std::fs;
use std::io::{self, Write};
use std::str::FromStr;
use tokio::time::{Duration, sleep};
use tracing::log::LevelFilter;

#[cfg(test)]
mod tests;

#[derive(Debug, Deserialize)]

struct Config {
    server_address: String,
    message_fetch_interval: u64,
    friend_fetch_interval: u64,
}

#[tokio::main]
async fn main() {
    // Configure logging for SQLx
    let options = SqliteConnectOptions::from_str("sqlite://mankeli.db")
        .expect("Failed to parse database URL")
        .log_statements(LevelFilter::Debug)
        .create_if_missing(true);

    let pool = SqlitePool::connect_with(options)
        .await
        .expect("Failed to connect to database");

    MIGRATOR.run(&pool).await.unwrap();

    //get config from json
    let data = fs::read_to_string("config.json").expect("Unable to read file");
    let config: Config = serde_json::from_str(&data).expect("JSON was not well-formatted");

    let username = read_input("Enter Username: ");

    let user: User = match retr_user(&pool).await {
        Ok(u) => {
            println!("\nWelcome back {}!\n", u.username);
            u
        }
        Err(e) => {
            eprintln!(
                "User not found or error retrieving user: {}. Initializing new user.",
                e
            );
            init_db(&pool, username, config.server_address.clone()).await
        }
    };

    //start message server
    let app = app(pool.clone()); //probably not good idea

    // Start the server

    let listener = tokio::net::TcpListener::bind(config.server_address)
        .await
        .unwrap();

    // Spawn the Axum server
    tokio::spawn(async move {
        if let Err(err) = axum::serve(listener, app).await {
            eprintln!("Server error: {}", err);
        }
    });

    // Spawn friend fetcher
    tokio::spawn({
        let pool = pool.clone();
        let interval = config.friend_fetch_interval;
        async move {
            let _ = friend_fetcher(&pool, interval).await;
        }
    });

    // Spawn message fetcher
    tokio::spawn({
        let pool = pool.clone();
        let username = user.username.clone();
        let address = user.address.clone();
        let interval = config.message_fetch_interval;
        async move {
            let _ = message_fetcher(&pool, &username, &address, interval).await;
        }
    });

    println!("\nWelcome {}!\n", &user.username);

    sleep(Duration::from_secs(2)).await;

    loop {
        let prompt =
            "\nAvailable commands: inbox, friends, send, outbound, quit\nPlease enter something: ";

        let cmd = read_input(prompt).to_lowercase();

        match cmd.as_str() {
            "inbox" => read_inbox(&pool).await,
            "friends" => read_friends(&pool).await,
            "send" => send_message(&pool).await,
            "outbound" => view_outbound(&pool).await,
            "quit" => {
                println!("Goodbye!");
                break;
            }
            _ => println!("Unknown command."),
        }
    }
}

fn read_input(prompt: &str) -> String {
    print!("{}", prompt);
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .expect("Failed to read input");
    input.trim().to_string()
}

async fn init_db(pool: &SqlitePool, username: String, address: String) -> User {
    let user = User {
        id: 0, // ID will be auto-generated by the DB
        username: username,
        address: address,
    };

    setup_db(pool, &user)
        .await
        .expect("Failed to set up database");

    retr_user(pool)
        .await
        .expect("Failed to retrieve newly created user")
}

async fn read_inbox(pool: &SqlitePool) {
    let inbox = match fetch_inbox(pool).await {
        Ok(messages) => messages,
        Err(e) => {
            eprintln!("Error fetching inbox: {}", e);
            return;
        }
    };

    if inbox.is_empty() {
        println!("You don't have any mail.");
        return;
    }

    println!("Your inbox:");
    for (i, message) in inbox.iter().enumerate() {
        println!(
            "{}. From: {}, Subject: {}",
            i + 1,
            message.sender,
            message.subject
        );
    }

    loop {
        print!("\nEnter message number to read in full, or 'b' to go back: ");
        io::stdout().flush().unwrap();

        let mut input = String::new();
        if let Err(_) = io::stdin().read_line(&mut input) {
            println!("Failed to read input. Try again.");
            continue;
        }

        let input = input.trim();

        if input.eq_ignore_ascii_case("b") {
            println!("Returning to main menu...");
            break;
        }

        match input.parse::<usize>() {
            Ok(index) if index > 0 && index <= inbox.len() => {
                let message = &inbox[index - 1];
                println!(
                    "\nFrom: {}\nSubject: {}\n\n{}",
                    message.sender, message.subject, message.message
                );

                print!("Delete this message? (y/n): ");
                io::stdout().flush().unwrap();

                let mut del_input = String::new();
                if let Ok(_) = io::stdin().read_line(&mut del_input) {
                    if del_input.trim().eq_ignore_ascii_case("y") {
                        match delete_message(pool, message.id).await {
                            Ok(_) => println!("Message deleted."),
                            Err(e) => println!("Failed to delete message: {}", e),
                        }
                    }
                }

                break;
            }
            _ => {
                println!("Invalid input. Please enter a valid number or 'b'.");
            }
        }
    }
}

async fn read_friends(pool: &SqlitePool) {
    // To-Do ADD option to accept and decline friend reques
    loop {
        let friends = match fetch_users(pool).await {
            Ok(friends) => friends,
            Err(e) => {
                eprintln!("Error fetching users: {}", e);
                return;
            }
        };

        println!("Your friends:");

        if friends.is_empty() {
            println!("You don't have any friends yet.");
        } else {
            println!(
                "{:<4} {:<15} {:<25} {:<18} {}",
                "ID", "Username", "Address", "Status", "Added At (UTC)"
            );
            println!("{}", "-".repeat(80));
            for fr in friends {
                println!(
                    "{:<4} {:<15} {:<25} {:<18} {}",
                    fr.id,
                    fr.username,
                    fr.address,
                    fr.status.status_str(),
                    fr.added_at
                        .map(|dt| dt.to_string())
                        .unwrap_or("N/A".to_string())
                );
            }
        }

        let response =
            read_input("a: Add Friend, r: remove Friend, i: invites, b: go back: ").to_lowercase();

        if response.as_str() == "b" {
            println!("Returning to main menu...");
            break;
        }

        match response.as_str() {
            "a" => {
                let username = read_input("Enter username of user: ");
                let address = read_input("Enter ip/hostname of user: ");
                let request = FriendRequest {
                    username: username,
                    address: address,
                };
                match send_invite(pool, &request).await {
                    Ok(_) => println!("Friend invite sent!"),
                    Err(e) => {
                        eprintln!("Error sending invite: {}", e);
                    }
                };
            }
            "r" => {
                let id = read_input("Enter friend id to remove them: ");

                match id.trim().parse::<i64>() {
                    Ok(friend_id) => {
                        println!("Removing friend with id: {}", friend_id);
                        match delete_user(pool, friend_id).await {
                            Ok(_) => println!("Friend removed."),
                            Err(e) => eprintln!("Failed to remove friend: {}", e),
                        }
                    }
                    Err(e) => {
                        println!("Invalid input: must be a number. Error: {}", e);
                    }
                }
            }
            "i" => {
                // Print invites
                let id = read_input("Select id to accept/reject request: ");
                let cmd = read_input("a: accept, r: reject: ");

                match id.trim().parse::<i64>() {
                    Ok(friend_id) => {
                        let decision = match cmd.trim() {
                            "a" => Some(true),
                            "r" => Some(false),
                            _ => {
                                println!("Invalid command. Use 'a' to accept or 'r' to reject.");
                                None
                            }
                        };

                        if let Some(accept) = decision {
                            match invite_decision(pool, friend_id, accept).await {
                                Ok(_) => {
                                    if accept {
                                        println!("Friend request accepted.");
                                    } else {
                                        println!("Friend request rejected.");
                                    }
                                }
                                Err(e) => eprintln!("Failed to process decision: {}", e),
                            }
                        }
                    }
                    Err(e) => {
                        println!("Invalid input: must be a number. Error: {}", e);
                    }
                }
            }

            _ => {
                println!("Invalid input. Please enter 'a', 'r', or 'b'.");
            }
        }
    }
}

async fn send_message(pool: &SqlitePool) {
    println!("Please fill the following fields");
    let send_to = read_input("Recipient: ");
    let subject = read_input("Subject: ");
    let content = read_input("Content: ");

    let message = OutgoingMessage {
        send_to,
        subject,
        content,
    };

    match send_message_to_que(pool, &message).await {
        Ok(_) => println!("Message queued!"),
        Err(e) => {
            eprintln!("Error queuing message: {}", e);
        }
    };
}

async fn view_outbound(pool: &SqlitePool) {
    let outbound = match fetch_outgoing(pool).await {
        Ok(outbound) => outbound,
        Err(e) => {
            eprintln!("Error fetching outbound messages: {}", e);
            return;
        }
    };

    println!("Your outbound mail:");
    if outbound.is_empty() {
        println!("You don't have any outbound messages.");
    } else {
        for message in outbound {
            println!(
                "To: {} | Subject: {} | Sent: {:?}",
                message.recipient, message.subject, message.sent
            )
        }
    }
}
